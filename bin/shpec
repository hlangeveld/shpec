#
: Use one of: bash, dash, or ksh93

indent() {
  printf '%*s' $(( (test_indent - 1) * 2))
}

# 'echo -e' is not a POSIX feature.
# This helps us to work around that.
echo_needs_minus_e(){
  echo "\010"| (read a; [ ${#a} -ne 1 ])
}

if echo_needs_minus_e; then
  echoe() { echo -e "$@"; }
else
  echoe() { echo "$@"; }
fi

iecho() {
  indent && echoe "$@"
}

sanitize() {
  IFS= echoe "$1" | tr '\n' 'n' | tr "'" 'q'
}

describe() {
  : $((test_indent += 1))
  iecho "$1"
}

end() {
  : $((test_indent -= 1))
  [ $test_indent -ge 0 ] && return
  printf -u 2 "Syntax Error in ${_shpec_file} file\n"
  exit 1
}

end_describe() {
  iecho "Warning: end_describe will be deprecated in shpec 1.0." \
    "Please use end instead."
  end
}

# Beware: POSIX shells are not required to accept
# any identifier as a function name.

stub_command() {
  body="${2:-:}"
  eval "$1() { $body; }"
}

unstub_command() { unset -f "$1"; }

it() {
  : $((test_indent += 1))
  : $((examples += 1))
  assertion="$1"
}

assert() {
  case "x$1" in
  xfail )
    set +e
    print_result "false" \
      "Always fails"
    set -e
  ;;
  xequal )
    print_result "[ '$(sanitize "$2")' = '$(sanitize "$3")' ]" \
      "Expected [$2] to equal [$3]"
  ;;
  xunequal )
    print_result "[ '$(sanitize "$2")' != '$(sanitize "$3")' ]" \
      "Expected [$2] not to equal [$3]"
  ;;
  xgt )
    print_result "[ $2 -gt $3 ]" \
      "Expected [$2] to be > [$3]"
  ;;
  xlt )
    print_result "[ $2 -lt $3 ]" \
      "Expected [$2] to be < [$3]"
  ;;
  xmatch )
    print_result "case '$2' in *$3*) :;; *) false;; esac" \
      "Expected [$2] to match [$3]"
  ;;
  xno_match )
    print_result "case '$2' in *$3*) false ;; *) :;; esac" \
      "Expected [$2] not to match [$3]"
  ;;
  xpresent )
    print_result "[ -n '$2' ]" \
      "Expected [$2] to be present"
  ;;
  xblank )
    print_result "[ -z '$2' ]" \
      "Expected [$2] to be blank"
  ;;

  xfile_present )
    print_result "[ -e $2 ]" \
      "Expected file [$2] to exist"
  ;;
  xfile_absent )
    print_result "[ ! -e $2 ]" \
      "Expected file [$2] not to exist"
  ;;
  xsymlink )
    link=$(readlink $2)
    print_result "[ '$link' = '$3' ]" \
      "Expected [$2] to link to [$3], but got [$link]"
  ;;
  xtest )
    print_result "$2" \
      "Expected $2 to be true"
  ;;
  * )
    if type "$1" 2>/dev/null | grep -q 'function'; then
      matcher="$1"; shift
      $matcher "$@"
    else
      print_result false "Error: Unknown matcher [$1]"
    fi
  ;;
  esac
}

skip()   { : $((_skipping+=1)); }
noskip() { [ ${_skipping} -eq 0 ]; }
_skipped(){ : $((_skipping-=1)); }

print_result() {
  if eval "$1"; then
    : $((passed += 1))
    iecho "$green$assertion$norm"
    return
  fi

  if noskip; then
    : $((failures += 1))
    iecho "$red$assertion$norm"
    iecho "($2)"
  else
    _skipped
    : $((skipped += 1))
    iecho "$yellow$assertion$norm"
    iecho "($2)"
  fi
}


shpec() {
  (
  VERSION=$(
    MAJOR=0
    MINOR=2
    PATCH=0
    echo $MAJOR.$MINOR.$PATCH
  )
  examples=0
  failures=0 expected_failures=0
  passed=0
  skipped=0

  test_indent=0 _skipping=0

  red="\033[0;31m"
  green="\033[0;32m"
  yellow="\033[0;33m"
  norm="\033[0m"
  [ -t 0 ] || red="NO " green="OK " yellow="?? " norm=

  SHPEC_ROOT=${SHPEC_ROOT:-$(
      [ -d './shpec' ] && echo './shpec' || echo '.'
  )}

  while option=$1
  do
    case $option in
    ( -v | --version )
                echo "$VERSION"
                exit 0
    ;;
    ( -f ) 
                shift
                expected_failures=$1 shift
    ;;
    (--)        shift
                break
    ;;
    (-* | --*)  shift
                printf -u2 -- "%s: no such option\n" $option
    ;;
    (*)         break
    esac
  done
  
  case "$1" in
  ( * )
      matcher_files=$(
          find "$SHPEC_ROOT/matchers" -name '*.sh' 2>/dev/null
      )

      for matcher_file in $matcher_files; do
        . "$matcher_file"
      done

      if [ $# -gt 0 ] ; then
        files="${@}"
      else
        files=$(
          find $SHPEC_ROOT -name '*_shpec.sh'
        )
      fi

      for file in $files; do
        . "$file"
      done

      (
      [ -t 0 ] || red= green= yellow= norm=
      echoe "${examples} ${norm}examples," \
              "${passed} ${green}passed${norm}" \
              "${failures} ${red}failures${norm}" \
              "${skipped} ${yellow}skipped${norm}"
      )

      times

      set -x
      [ $failures -eq $expected_failures ]
      exit
  ;;
  esac
  )
}

(
  _progname=shpec
  _pathname=$( command -v $0 )
  _cmdname=${_pathname##*/}
  _main=shpec

  case $_progname in (${_cmdname%.sh}) $_main "$@";; esac
)
